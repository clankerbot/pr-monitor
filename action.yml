name: 'PR Monitor'
description: 'Waits for all other workflow checks to complete and reports aggregate status'
author: 'thekevinscott'

inputs:
  job-name:
    description: 'Name of the job running this action (required to exclude itself)'
    required: true
  excluded-jobs:
    description: 'Comma-separated list of additional job names to exclude from monitoring'
    required: false
    default: ''
  pre-sleep:
    description: 'Time in seconds to wait before checking (allows other workflows to start)'
    required: false
    default: '10'
  check-interval:
    description: 'Time in seconds between status checks'
    required: false
    default: '5'
  timeout:
    description: 'Maximum time in minutes to wait for all checks'
    required: false
    default: '10'
  github-token:
    description: 'GitHub token for API access'
    required: false
    default: ${{ github.token }}

runs:
  using: 'composite'
  steps:
    - name: Wait for all checks
      uses: actions/github-script@v7
      env:
        JOB_NAME: ${{ inputs.job-name }}
        EXCLUDED_JOBS: ${{ inputs.excluded-jobs }}
        PRE_SLEEP: ${{ inputs.pre-sleep }}
        CHECK_INTERVAL: ${{ inputs.check-interval }}
        TIMEOUT: ${{ inputs.timeout }}
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const PRE_SLEEP = parseInt(process.env.PRE_SLEEP) * 1000;
          const CHECK_INTERVAL = parseInt(process.env.CHECK_INTERVAL) * 1000;
          const MAX_DURATION = parseInt(process.env.TIMEOUT) * 60 * 1000;

          // Build exclusion list from job name and any additional excluded jobs
          const jobName = process.env.JOB_NAME;
          const userExcluded = process.env.EXCLUDED_JOBS
            ? process.env.EXCLUDED_JOBS.split(',').map(s => s.trim()).filter(Boolean)
            : [];
          const EXCLUDED_JOBS = [jobName, ...userExcluded];

          const { owner, repo } = context.repo;

          // Get commit SHA - works for both PR and push events
          const commit_sha = context.payload.pull_request?.head?.sha || context.sha;

          console.log(`Sleeping ${Math.round(PRE_SLEEP / 1000)}s to allow other workflows to start`);
          await sleep(PRE_SLEEP);
          const start = performance.now();

          console.log(`Monitoring checks for commit: ${commit_sha}`);
          console.log(`Excluded jobs: ${JSON.stringify(EXCLUDED_JOBS)}`);

          async function fetchCheckRuns() {
            const response = await github.rest.checks.listForRef({
              owner,
              repo,
              ref: commit_sha,
              per_page: 100
            });
            return response.data.check_runs;
          }

          async function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
          }

          let checkRuns = await fetchCheckRuns();
          console.log('Found check runs:', checkRuns.map(r => r.name));

          // Filter to non-excluded jobs
          const relevantRuns = checkRuns.filter(run => !EXCLUDED_JOBS.includes(run.name));

          // It's OK if no other workflows run (e.g., docs-only PR)
          if (relevantRuns.length === 0) {
            console.log('No other workflows to monitor - this is OK for docs-only PRs');
            return;
          }

          let inProgressFound = [];
          let failureFound = [];

          do {
            inProgressFound = [];
            failureFound = [];

            for (const { name, status, conclusion } of checkRuns) {
              if (!EXCLUDED_JOBS.includes(name)) {
                if (status === 'in_progress' || status === 'queued' || status === 'pending') {
                  inProgressFound.push(name);
                }
                if (conclusion === 'failure') {
                  failureFound.push(name);
                }
              }
            }

            if (inProgressFound.length) {
              if (performance.now() - start > MAX_DURATION) {
                core.setFailed(`Exceeded max duration of ${Math.round(MAX_DURATION / 1000 / 60)} minutes`);
                break;
              }
              const duration = Math.round((performance.now() - start) / 1000);
              console.log(`In progress: ${JSON.stringify(inProgressFound)} | elapsed: ${duration}s`);
              await sleep(CHECK_INTERVAL);
              checkRuns = await fetchCheckRuns();
            }
          } while (inProgressFound.length);

          if (failureFound.length) {
            core.setFailed(`Failed checks: ${JSON.stringify(failureFound)}`);
          } else {
            console.log('All checks completed successfully');
          }

branding:
  icon: 'check-circle'
  color: 'green'
